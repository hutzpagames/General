<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peer.min.js"></script>

    <style>
        :root {
            --alias-red: #d92d20;
            --alias-white: #ffffff;
            --alias-dark: #2c2c2c;
            --alias-light-gray: #f7f7f7;
        }

        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            font-family: 'Rubik', sans-serif;
            touch-action: manipulation;
            background-color: var(--alias-light-gray);
        }

        #layout-container { display: flex; flex-direction: column; height: 100%; }
        #app-wrapper { flex-grow: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding: 1rem; padding-bottom: calc(1rem + env(safe-area-inset-bottom)); }
        #setup-screen, #game-screen { max-height: none; overflow-y: visible; }
        #app-container { display: flex; flex-direction: column; justify-content: center; }
        .alias-title { font-weight: 900; color: var(--alias-red); text-shadow: 3px 3px 0px rgba(0,0,0,0.05); }
        .card { -webkit-perspective: 1000; perspective: 1000; transform-style: preserve-3d; transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1); }
        .card.is-flipped { transform: rotateY(180deg); }
        .card__face { -webkit-backface-visibility: hidden; backface-visibility: hidden; position: absolute; width: 100%; height: 100%; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); border: 2px solid var(--alias-dark); }
        .card__face--front { background-color: var(--alias-white); color: var(--alias-dark); }
        .card__face--back { transform: rotateY(180deg); background-color: var(--alias-red); color: var(--alias-white); border-color: var(--alias-red); }
        .btn { transition: all 0.15s ease-in-out; border-radius: 0.75rem; font-weight: 700; }
        .btn:active { transform: scale(0.96); filter: brightness(0.95); }
        .btn-red { background-color: var(--alias-red); color: var(--alias-white); }
        .btn-outline { background-color: var(--alias-white); color: var(--alias-red); border: 2px solid var(--alias-red); }
        .score-box { background-color: var(--alias-white); border: 2px solid #e5e7eb; color: var(--alias-dark); transition: all 0.3s ease-in-out; border-radius: 0.5rem; position: relative; overflow: hidden; }
        .score-box.active { border: 2px solid var(--alias-red); }
        .modal-content { transition: opacity 0.25s ease-in-out, transform 0.25s ease-in-out; }
        .btn-outline.selected { background-color: var(--alias-red); color: var(--alias-white); }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0; }
    </style>

    <title>拽爪 砖 - 砖拽</title>
</head>

<body>

<div id="layout-container">
    <main id="app-wrapper">
        <div id="app-container" class="w-full max-w-md mx-auto">
            
            <div id="connection-screen" class="bg-white p-6 md:p-8 rounded-xl shadow-lg text-center">
                <h1 class="text-6xl mb-4 alias-title">拽爪 砖</h1>
                <p class="text-gray-500 mb-8">砖拽  注 专</p>
                <div class="space-y-4">
                    <button id="host-game-btn" class="w-full py-4 px-6 text-2xl shadow-lg transform btn btn-red">
                        爪专 砖拽 砖 (专)
                    </button>
                    <div class="my-4 text-gray-400"></div>
                    <div class="flex gap-2">
                        <input type="text" id="join-id-input" placeholder="住 拽 砖拽" class="w-full p-3 border-2 border-gray-300 rounded-lg text-center text-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 transition">
                        <button id="join-game-btn" class="py-3 px-6 text-lg shadow-md transform btn btn-outline">
                            爪专祝
                        </button>
                    </div>
                </div>
                 <div id="connection-status" class="mt-4 text-sm text-gray-500 h-5"></div>
            </div>

            <div id="setup-screen" class="hidden bg-white p-6 md:p-8 rounded-xl shadow-lg text-center">
                
                <div id="lobby-info" class="mb-6 text-right p-4 bg-gray-50 rounded-lg border">
                    <p class="font-bold text-lg">拽 砖拽: <span id="session-id-display" class="font-mono text-red-600 select-all tracking-wider"></span></p>
                    <p class="font-bold mt-2">砖拽 专 (<span id="player-count">1</span>):</p>
                    <ul id="player-list" class="list-disc list-inside text-gray-700">
                        <li>转 (专)</li>
                    </ul>
                </div>

                <h1 class="text-4xl mb-2 alias-title">专转 砖拽</h1>
                
                <div id="team-inputs-container" class="space-y-4 mb-4">
                    <div class="flex items-center gap-2">
                        <label for="team1-name" class="sr-only">砖 拽爪 1</label>
                        <input type="text" id="team1-name" placeholder="砖 拽爪 1" value="拽爪 '" class="team-name-input w-full p-3 border-2 border-gray-300 rounded-lg text-center text-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 transition">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="team2-name" class="sr-only">砖 拽爪 2</label>
                        <input type="text" id="team2-name" placeholder="砖 拽爪 2" value="拽爪 '" class="team-name-input w-full p-3 border-2 border-gray-300 rounded-lg text-center text-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 transition">
                    </div>
                </div>
                <button id="add-team-btn" class="w-full mb-6 py-2 px-4 text-md text-red-600 font-semibold rounded-lg border-2 border-dashed border-red-300 hover:bg-red-50 transition">
                    + 住祝 拽爪
                </button>

                <div class="mb-8">
                    <fieldset>
                        <legend class="block text-sm font-medium text-gray-700 mb-2">拽转 爪</legend>
                        <div id="score-options" class="flex justify-center gap-2 max-w-xs mx-auto">
                            <button class="score-option w-full py-3 btn btn-outline" data-value="10">10</button>
                            <button class="score-option w-full py-3 btn btn-outline selected" data-value="20">20</button>
                            <button class="score-option w-full py-3 btn btn-outline" data-value="50">50</button>
                        </div>
                    </fieldset>
                </div>

                <button id="start-game-btn" class="w-full py-4 px-6 text-2xl shadow-lg transform btn btn-red mb-4">
                    转 砖拽
                </button>
                <div class="mt-4">
                    <a href="http://hutzpa.games/PrivacyPolicies/KtzeHalashon" target="_blank" rel="noopener noreferrer" class="text-gray-500 hover:text-red-600 text-sm underline">转 驻专转</a>
                </div>
            </div>

            <div id="game-screen" class="hidden w-full">
                <div id="game-content">
                    <div class="flex items-start justify-center gap-3 mb-6">
                        <div id="scores-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 flex-grow">
                        </div>
                        <div class="text-center bg-white rounded-lg p-2 shadow-md flex-shrink-0">
                            <div class="text-5xl font-black text-gray-800" id="timer">60</div>
                            <div class="text-sm text-gray-500">砖转</div>
                        </div>
                    </div>

                    <div class="relative h-64 mb-6">
                        <div class="card w-full h-full" id="word-card">
                            <div class="card__face card__face--front flex items-center justify-center p-6">
                                <div id="card-front-content" class="text-center">
                                    <h2 class="text-2xl md:text-3xl font-bold">转专 砖 <span id="current-team-name-card"></span></h2>
                                    <p class="text-gray-500 mt-2">拽爪 转转 爪 注 拽祝</p>
                                </div>
                            </div>
                            <div class="card__face card__face--back flex items-center justify-center p-6">
                                <h2 id="word-display" class="text-5xl font-extrabold text-center"></h2>
                            </div>
                        </div>
                    </div>

                    <div id="action-buttons" class="grid grid-cols-2 gap-4 hidden">
                        <button id="skip-btn" class="py-5 px-6 text-2xl shadow-lg transform btn btn-outline"></button>
                        <button id="correct-btn" class="py-5 px-6 text-2xl shadow-lg transform btn btn-red">爪!</button>
                    </div>
                </div>
                <div id="waiting-for-host" class="hidden text-center">
                     <h2 class="text-3xl text-gray-600">转 专 砖转 转 砖拽...</h2>
                </div>
            </div>

             <div id="turn-over-modal" role="dialog" aria-modal="true" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
                <div class="bg-white p-8 rounded-xl shadow-xl text-center max-w-sm w-full modal-content">
                    <h2 class="text-4xl font-black text-gray-800 mb-2"> 专!</h2>
                    <p class="text-lg text-gray-600 mb-4">
                         , <span id="finished-team-name" class="font-bold"></span>!
                    </p>
                    <p class="text-gray-500 mb-6">
                        爪转 <span id="turn-score" class="font-bold text-2xl" style="color: var(--alias-red);">0</span> .
                    </p>
                    <button id="next-turn-btn" class="w-full py-3 px-6 text-xl shadow-lg transform btn btn-red">
                        转专 
                    </button>
                </div>
            </div>
            <div id="winning-screen" role="dialog" aria-modal="true" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
                <div class="bg-white p-8 rounded-xl shadow-xl text-center max-w-sm w-full transform scale-95 opacity-0 modal-content" id="winning-modal-content">
                    <div class="text-6xl mb-4"></div>
                    <h2 class="text-4xl font-black text-gray-800 mb-2">爪!</h2>
                    <p class="text-lg text-gray-600 mb-6">
                        拽爪转 <span id="winning-team-name" class="font-bold text-2xl" style="color: var(--alias-red);"></span> 爪!
                    </p>
                    <button id="play-again-btn" class="w-full py-3 px-6 text-xl shadow-lg transform btn btn-red">
                        砖拽 砖
                    </button>
                </div>
            </div>
        </div>
    </main>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // =======================================================
    // PEER-TO-PEER AND NETWORKING LOGIC
    // =======================================================
    let peer;
    let hostConnection; // For players to talk to the host
    const playerConnections = new Map(); // For the host to talk to players (Map<peerId, conn>)
    let myPeerId;
    let isHost = false;

    // --- DOM Elements for Networking ---
    const connectionScreen = document.getElementById('connection-screen');
    const setupScreen = document.getElementById('setup-screen');
    const gameScreen = document.getElementById('game-screen');
    const hostGameBtn = document.getElementById('host-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const joinIdInput = document.getElementById('join-id-input');
    const sessionIdDisplay = document.getElementById('session-id-display');
    const playerList = document.getElementById('player-list');
    const playerCount = document.getElementById('player-count');
    const connectionStatus = document.getElementById('connection-status');
    
    // --- Initialization ---
    function initializePeer(id = null) {
        connectionStatus.textContent = '转专 专砖转...';
        peer = id ? new Peer(id) : new Peer();

        peer.on('open', (id) => {
            console.log('My peer ID is: ' + id);
            myPeerId = id;
            if (isHost) {
                sessionIdDisplay.textContent = id;
                connectionScreen.classList.add('hidden');
                setupScreen.classList.remove('hidden');
            }
            connectionStatus.textContent = '';
        });

        peer.on('error', (err) => {
            console.error('PeerJS Error:', err);
            if (err.type === 'peer-unavailable') {
                 connectionStatus.textContent = `砖: 拽 砖拽  爪.`;
            } else {
                 connectionStatus.textContent = `砖. 住 专注 转 注.`;
            }
        });

        if (isHost) {
            peer.on('connection', (conn) => {
                console.log('Incoming connection from', conn.peer);
                playerConnections.set(conn.peer, conn);
                updatePlayerList();
                
                conn.on('data', (data) => {
                    handlePlayerMessage(conn.peer, data);
                });
                
                conn.on('close', () => {
                    console.log(`Connection closed with ${conn.peer}`);
                    playerConnections.delete(conn.peer);
                    updatePlayerList();
                });
            });
        }
    }
    
    // --- Event Listeners for Networking Buttons ---
    hostGameBtn.addEventListener('click', () => {
        isHost = true;
        initializePeer();
    });

    joinGameBtn.addEventListener('click', () => {
        const hostId = joinIdInput.value.trim();
        if (!hostId) {
            alert('砖 住 拽 砖拽');
            return;
        }
        isHost = false;
        initializePeer(); 

        setTimeout(() => {
            if (!peer) return;
            console.log(`Attempting to connect to host: ${hostId}`);
            connectionStatus.textContent = `转专 -${hostId}...`;
            hostConnection = peer.connect(hostId);

            hostConnection.on('open', () => {
                console.log('Successfully connected to host!');
                connectionStatus.textContent = '专!';
                connectionScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                document.getElementById('game-content').classList.add('hidden');
                document.getElementById('waiting-for-host').classList.remove('hidden');
            });

            hostConnection.on('data', (data) => {
                handleHostMessage(data);
            });
            hostConnection.on('error', (err) => {
                console.error("Connection error:", err);
                connectionStatus.textContent = "砖转 专 专."
            });

        }, 500);
    });

    function updatePlayerList() {
        if(!isHost) return;
        playerList.innerHTML = '<li>转 (专)</li>';
        for (const peerId of playerConnections.keys()) {
            const playerLi = document.createElement('li');
            playerLi.textContent = `砖拽 (${peerId.slice(0, 5)}...)`;
            playerList.appendChild(playerLi);
        }
        playerCount.textContent = playerConnections.size + 1;
    }

    // --- Communication Functions ---
    function broadcastToPlayers(data) {
        if (!isHost) return;
        for (const conn of playerConnections.values()) {
            conn.send(data);
        }
    }
    
    function sendToHost(data) {
        if (isHost || !hostConnection) return;
        hostConnection.send(data);
    }
    
    // =======================================================
    // GAME STATE AND LOGIC
    // =======================================================
    
    const defaultWords = ["砖", "住", "砖", "驻", "", "专抓", "砖", "转", "", "转", "砖砖", "专", "住驻专", "转 住驻专", "", "驻砖", "", "专拽", "砖拽驻", "注", "驻驻", "注", "砖", "专", "专", "专住", "住", "专转", "驻", "拽", "专", "驻住转专", " 转", "转", "", "注", "转", "转拽", "砖驻", "专", "注", "住祝", "拽", "拽", "转", " ", "转", "注", "注", "专", "爪", "住", "砖", "", "住专", "砖转", "专", "拽转", "注专", "驻住转", "", "", "转", "驻转", "", "砖", "专转", "专", "专", "专", "专砖转 砖", "住", "砖驻", "", "砖", "爪", "", "", "", "转拽", "", "注住", "驻", "", "爪拽", "注", "", "", "", "", "专", "祝", "", "驻", "注", "砖注专", "爪驻专", "爪注", "拽抓", "专祝", "", "住转", "驻专", "注抓", "砖", "专", "专", "专", "'", "驻", "爪驻", "", "拽住", "专 专抓", "转", "住专", "注", "专驻", "专", "砖专", "", "", "专", "砖拽", "专拽", "爪专", "住驻专", "专", "专", "驻", "'专驻", "拽祝", "专", "驻驻", "转", "砖", "爪", "驻", "专砖", "转", "驻", "", "", "砖注", "爪", "砖祝", "砖专", "住", "注专 ", "注爪", "转转", "", "", "住驻专", "驻", "拽专", "驻住", "驻爪", "专专", "住砖", "砖爪", "专", "转驻 ", "", "专", "爪", "砖", "驻驻", "爪", "拽砖", "专拽", "专转", "转专住", "驻", "住", "", "驻驻", "砖专", "拽驻", "转", "抓", "", "专", "专砖", "转 ", "驻", "专 砖注", "转", "爪专", "专", "专爪转 专转", "住", "驻", "专住", "爪专驻转", "", "", "住驻专", "专", "转 拽驻", "住注", "住驻专", "", "转专", "拽注", "专", "驻专拽", " 转", "砖 转注驻", "转转 专转", "转", "注 砖专", "爪注转", "转祝", "专驻拽", "砖专砖 祝 ", "专", "拽专住", "注拽", "专转", "", "拽", "", "", "驻", "注", "爪拽", "祝", "", "注专", "砖", "专", "注专", "专 注砖", "", "爪注祝", "驻驻转", "注", "专", "爪", "砖专砖专转", "注", "注转", "砖注", "转拽", "转专", "", "驻转", "驻砖", "专", "住专", "爪转", "拽", "专", "砖驻", "抓", "住转", "拽", "", "", "驻转注", "", "住拽专转", "", "注爪转", "", "拽爪", "转", "拽专", "爪专", "砖专", "专拽", "砖", "驻转", "拽转", "住专", "拽转", "专", "", "", "住", "砖转", "爪", "驻住", "砖", "拽", "砖", "专", "砖", "", "住专", "砖", "注转", "拽砖", "专", "爪注拽", "砖", "住驻", "专住", "砖", "转", "注爪抓", "专", "住专", "转", "爪转", "拽注专", "住", "住驻", "拽拽", "拽专", "转专", "拽专专", "拽驻", " ", "转 住", "砖", "抓", "拽专砖 抓", "砖 拽", "", "注", "", "住专", "住", "砖", "专爪", "驻", "", "驻住", "专转 砖拽转", "砖", "住拽", "砖", "", "爪", "", "砖拽 砖", "", "拽驻", "拽专", "拽驻", "住爪", "住专", "专驻", "转拽", "驻拽", "", "", "驻住驻", "驻住", "转", "注", "", "拽", "爪拽", "驻砖", "砖", "专转", "爪", "砖", "注转", "注专", "", "住", "转", "砖转", "拽注", "住拽", "住驻", "", "专砖 砖", "拽专拽", "专 砖拽", "", "专", "专", "", "转 ", "专驻", "砖专", "注专", "住转", "转 砖驻", "驻住", "拽爪专", "爪", "转注专", "驻", "专转", "住", "专", "拽住", "驻", "注抓", "转转", "驻住拽", "转", "", "爪专", "注专", "", "", "", "专", "砖", "", "", "爪", "专拽", "转", "住", "专", "", "砖专", "", "驻专", "住祝", "", "", "", "", "转", "住", "住转", "", "", " ", "转 ", "", "转", "专", "转注转 转", "专砖 ", "专住 砖专", "", "砖", "拽", "专转", "", "住","砖拽专", "转", "专注", "注", "驻转专", "砖", "转砖", "住驻专", "砖专", "住", "住", "专转 拽专", "专转 爪专", "专转 注专", "拽", " 专砖", " 注拽专转", "专", "", "", "驻", "砖", "", "转", "转", "专", "", "住专", "拽", "砖", "", "", "爪", "", "专", "", "注", "砖拽", "", "住专", "住拽", "专", "", "专转", "", "专", "注拽", "砖拽", "驻专专", "抓", "专注砖", "砖拽", "专", "砖", "爪专", "", "转", "转", "专", "", "爪注", "砖转", "注祝", "驻", "住", "转拽爪", "爪", "住", "住", "砖拽注", "专住", "", "专转", "", "砖转", "", "驻住", "驻专砖", "专", "", "住", "", "注", "砖", " ", "转 ", "转", "", "住", "住", "", "转", "", "注专", "专", "拽砖砖", "", "", "砖", "砖", "专砖", "驻", "砖", "砖", "砖驻转", "住专", "爪专", "", "", "", "专注", "祝 专", "注专", "", "注爪", "砖专专", "", "住住", "驻专", "专", "砖", "注", "转专", "专", "", "爪驻专", "驻专驻专", "专", "", "注砖", "转砖", "", "住专", "转", "", "拽", "拽住拽住", "专", "住", "驻专", "注转", "转驻", "", "转驻", "注", "", "", "转转", "", "驻专住拽", "砖砖", "砖祝", "", "拽", "注砖", "砖注注转", "驻", "砖转", "砖专", "注祝", "拽爪爪", "住拽", "拽拽", "拽专住", "专拽住", "住", "专拽", "专", "转", "住", "住", "砖拽", "专", "拽砖驻", "", "砖", "祝", "", "住\"", "", "住", "祝", "驻转", "拽专砖 转", "驻转", "专 砖", "住", "", "专 ", "砖专转", "专驻住转", "", "注转", "砖转 砖", "专 ", "爪转", "'住", "住专", "'拽", "注", "砖拽驻 砖砖", "转砖", "砖", "专", "专", "住驻", "专拽", "专注", "拽砖转 注", "注拽", "砖", "专", "", "专", "注专", "砖转", "专住", " ", "转 专拽转", "专 砖专", "专", "驻注", "砖专", "驻注", "爪专", "驻拽", "砖", "拽驻抓", "砖转", "注", "砖", "专", "注转", "转拽", "转砖", "专爪转", "拽拽", "专砖", "转", "转拽", "爪", "", "拽", "专", "拽爪专", "注", "专注", "注爪", "注祝", "专注", "爪", "驻", "驻转注", "专砖", "砖注", "", "专注", "驻", "注专", "驻砖", "专", "", "转", "", "住", "转爪", "转注", "拽", "注", "注", "", "", "转转", "", "专", "拽爪转", "", "转", "驻注", "祝 驻注", " 砖注", " 砖", "转 专", "注  专", " 注", " 专", "砖 ", " 砖"];
    
    let words = [...defaultWords];
    let availableWords = [];

    const state = {
        teams: [],
        currentTeamIndex: 0,
        timerInterval: null,
        timeLeft: 60,
        gameActive: false,
        turnScore: 0,
        roundTime: 60,
        winningScore: 20,
        isMyTurn: false,
    };

    // --- DOM Elements for Game ---
    const turnOverModal = document.getElementById('turn-over-modal');
    const winningScreen = document.getElementById('winning-screen');
    const winningModalContent = document.getElementById('winning-modal-content');
    const teamInputsContainer = document.getElementById('team-inputs-container');
    const addTeamBtn = document.getElementById('add-team-btn');
    const scoreOptions = document.getElementById('score-options');
    const startGameBtn = document.getElementById('start-game-btn');
    const scoresContainer = document.getElementById('scores-container');
    const timerDisplay = document.getElementById('timer');
    const wordDisplay = document.getElementById('word-display');
    const wordCard = document.getElementById('word-card');
    const actionButtons = document.getElementById('action-buttons');
    const currentTeamNameCard = document.getElementById('current-team-name-card');
    const correctBtn = document.getElementById('correct-btn');
    const skipBtn = document.getElementById('skip-btn');
    const finishedTeamName = document.getElementById('finished-team-name');
    const turnScoreDisplay = document.getElementById('turn-score');
    const nextTurnBtn = document.getElementById('next-turn-btn');
    const winningTeamName = document.getElementById('winning-team-name');
    const playAgainBtn = document.getElementById('play-again-btn');
    const cardFrontContent = document.getElementById('card-front-content');

    // --- Game Setup Event Listeners ---
    startGameBtn.addEventListener('click', () => { if(isHost) startGame(); });
    addTeamBtn.addEventListener('click', addTeamInput);
    teamInputsContainer.addEventListener('click', (e) => { if (e.target && e.target.classList.contains('remove-team-btn')) { e.target.parentElement.remove(); } });
    scoreOptions.addEventListener('click', (e) => { if (e.target.classList.contains('score-option')) { scoreOptions.querySelectorAll('.score-option').forEach(btn => btn.classList.remove('selected')); e.target.classList.add('selected'); } });
    
    // --- In-Game Event Listeners ---
    wordCard.addEventListener('click', () => {
        if(state.isMyTurn && !state.gameActive) {
            sendToHost({ type: 'start_turn' });
        }
    });

    correctBtn.addEventListener('click', () => sendToHost({ type: 'action', payload: 'correct' }));
    skipBtn.addEventListener('click', () => sendToHost({ type: 'action', payload: 'skip' }));
    nextTurnBtn.addEventListener('click', () => { if(isHost) setupNextTurn(); });
    playAgainBtn.addEventListener('click', () => { if(isHost) resetGame(); });

    // --- Message Handling ---
    function handleHostMessage(data) {
        switch (data.type) {
            case 'game_start':
            case 'state_update':
                Object.assign(state, data.payload.state); // Update local state
                availableWords = data.payload.availableWords || []; // Sync word list
                renderGameUI();
                break;
            case 'your_turn':
                state.isMyTurn = true;
                renderGameUI(); // Show "your turn" message
                break;
            case 'show_word':
                wordCard.classList.add('is-flipped');
                wordDisplay.textContent = data.payload.word;
                actionButtons.classList.remove('hidden');
                startTimer();
                break;
            case 'turn_over':
                endTurn(data.payload);
                break;
            case 'game_over':
                showWinningScreen(data.payload.winningTeam);
                break;
            case 'reset':
                window.location.reload();
                break;
        }
    }
    
    function handlePlayerMessage(peerId, data) {
        if (!isHost) return;
        switch (data.type) {
            case 'start_turn':
                if (!state.gameActive) {
                    const word = getNextWord();
                    const playerConn = Array.from(playerConnections.values())[state.currentTeamIndex-1]; // Simple mapping, needs improvement for robustness
                    // Send word to the specific player whose turn it is.
                    // This mapping is simplified. Assumes player connection order matches team order.
                    // A robust solution would map player IDs to teams.
                    const allConns = [null, ...playerConnections.values()]; // null for host at index 0
                    const conn = allConns[state.currentTeamIndex];
                    if(conn){
                        conn.send({ type: 'show_word', payload: { word } });
                    } else { // It's the host's turn
                        wordCard.classList.add('is-flipped');
                        wordDisplay.textContent = word;
                        actionButtons.classList.remove('hidden');
                    }
                    startTimer();
                }
                break;
            case 'action':
                if (state.gameActive) {
                    if (data.payload === 'correct') handleCorrect();
                    else if (data.payload === 'skip') handleSkip();
                }
                break;
        }
    }
    
    // --- UI Rendering ---
    function renderGameUI() {
        // Show the main game content if it's hidden
        document.getElementById('game-content').classList.remove('hidden');
        document.getElementById('waiting-for-host').classList.add('hidden');
        
        setupScreen.classList.add('hidden');
        gameScreen.classList.remove('hidden');
        turnOverModal.classList.add('hidden');
        winningScreen.classList.add('hidden');
        
        // Render scoreboard
        scoresContainer.innerHTML = '';
        state.teams.forEach((team, index) => {
            const scoreBox = document.createElement('div');
            scoreBox.className = 'score-box p-3 rounded-lg text-center shadow-md';
            if (index === state.currentTeamIndex) {
                scoreBox.classList.add('active');
            }
            scoreBox.innerHTML = `
                <div class="font-bold text-base md:text-lg truncate">${team.name}</div>
                <div class="text-2xl font-black">${team.score}</div>`;
            scoresContainer.appendChild(scoreBox);
        });

        // Render card front
        const currentTeam = state.teams[state.currentTeamIndex];
        currentTeamNameCard.textContent = currentTeam.name;
        if(state.isMyTurn) {
            cardFrontContent.innerHTML = `<h2 class="text-3xl font-bold">转专 砖!</h2><p class="text-gray-500 mt-2">抓 注 拽祝  转</p>`;
            // Host on their own turn
            if(isHost && state.currentTeamIndex === 0){
                cardFrontContent.innerHTML = `<h2 class="text-3xl font-bold">转专 砖 (专)!</h2><p class="text-gray-500 mt-2">抓 注 拽祝  转</p>`;
                 wordCard.onclick = () => {
                    if(!state.gameActive){
                        const word = getNextWord();
                        wordCard.classList.add('is-flipped');
                        wordDisplay.textContent = word;
                        actionButtons.classList.remove('hidden');
                        startTimer();
                        correctBtn.onclick = handleCorrect;
                        skipBtn.onclick = handleSkip;
                    }
                 }
            }
        } else {
             cardFrontContent.innerHTML = `<h2 class="text-2xl md:text-3xl font-bold">转专 砖 <span id="current-team-name-card">${currentTeam.name}</span></h2><p class="text-gray-500 mt-2">转 砖 转...</p>`;
             wordCard.onclick = null;
        }

        // Reset card state for next turn
        wordCard.classList.remove('is-flipped');
        actionButtons.classList.add('hidden');
        timerDisplay.textContent = state.roundTime;
        timerDisplay.parentElement.classList.remove('animate-pulse', 'bg-red-200');
    }

    // --- Core Game Logic (mostly HOST-SIDE) ---
    function addTeamInput() {
        const teamCount = teamInputsContainer.children.length;
        const newTeamInput = document.createElement('div');
        newTeamInput.className = 'flex items-center gap-2';
        newTeamInput.innerHTML = `<input type="text" placeholder="砖 拽爪 ${teamCount + 1}" class="team-name-input w-full p-3 border-2 border-gray-300 rounded-lg text-center text-lg"><button class="remove-team-btn text-gray-400 hover:text-red-500 text-2xl font-bold">&times;</button>`;
        teamInputsContainer.appendChild(newTeamInput);
    }
    
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function getNextWord() {
        if (availableWords.length === 0) {
            availableWords = [...words];
            shuffle(availableWords);
        }
        return availableWords.pop();
    }

    function startGame() {
        state.teams = [];
        document.querySelectorAll('.team-name-input').forEach((input, index) => {
            state.teams.push({ name: input.value || `拽爪 ${index + 1}`, score: 0 });
        });
        
        // A simple check to ensure there are players for teams.
        // The host is always team 0. Each connected player is a subsequent team.
        if (playerConnections.size + 1 < state.teams.length) {
            alert(` 住驻拽 砖拽 专 注专 ${state.teams.length} 拽爪转. 专: ${playerConnections.size + 1}.`);
            return;
        }

        state.winningScore = parseInt(scoreOptions.querySelector('.selected').dataset.value);
        state.currentTeamIndex = 0;
        state.turnScore = 0;
        state.gameActive = false;
        
        availableWords = [...words];
        shuffle(availableWords);

        const payload = { state, availableWords };
        broadcastToPlayers({ type: 'game_start', payload });

        // Tell the first player it's their turn
        const firstPlayerConn = Array.from(playerConnections.values())[0];
        if (state.teams.length > 1 && firstPlayerConn) {
             // Let's assume team 0 is host, team 1 is first player, etc.
             // This is a simplification.
            state.isMyTurn = false; // Host's turn is not now
            firstPlayerConn.send({ type: 'your_turn' });
        } else {
            state.isMyTurn = true; // It's the host's turn
        }
        
        renderGameUI();
    }

    function startTimer() {
        state.gameActive = true;
        state.timeLeft = state.roundTime;
        
        const update = () => {
            timerDisplay.textContent = state.timeLeft;
            if (state.timeLeft <= 10) {
                timerDisplay.parentElement.classList.add('animate-pulse', 'bg-red-200');
            }
        };
        update();
        
        state.timerInterval = setInterval(() => {
            state.timeLeft--;
            update();
            if (state.timeLeft <= 0) {
                if (isHost) {
                    const payload = { turnScore: state.turnScore, teamName: state.teams[state.currentTeamIndex].name };
                    broadcastToPlayers({ type: 'turn_over', payload });
                    endTurn(payload); // Also for host
                }
            }
        }, 1000);
    }
    
    function handleCorrect() {
        if (!isHost || !state.gameActive) return;
        state.teams[state.currentTeamIndex].score++;
        state.turnScore++;
        
        // Get new word and send it
        const nextWord = getNextWord();
        const allConns = [null, ...playerConnections.values()];
        const conn = allConns[state.currentTeamIndex];
        if(conn){
             conn.send({ type: 'show_word', payload: { word: nextWord } });
        } else { // Host's turn
            wordDisplay.textContent = nextWord;
        }

        broadcastToPlayers({ type: 'state_update', payload: { state, availableWords } });
        renderGameUI();
    }

    function handleSkip() {
        if (!isHost || !state.gameActive) return;
        if (state.teams[state.currentTeamIndex].score > 0) {
            state.teams[state.currentTeamIndex].score--;
        }
        
        const nextWord = getNextWord();
        const allConns = [null, ...playerConnections.values()];
        const conn = allConns[state.currentTeamIndex];
         if(conn){
             conn.send({ type: 'show_word', payload: { word: nextWord } });
        } else { // Host's turn
            wordDisplay.textContent = nextWord;
        }

        broadcastToPlayers({ type: 'state_update', payload: { state, availableWords } });
        renderGameUI();
    }

    function endTurn(payload) {
        clearInterval(state.timerInterval);
        state.gameActive = false;
        state.isMyTurn = false;
        
        finishedTeamName.textContent = payload.teamName;
        turnScoreDisplay.textContent = payload.turnScore;
        turnOverModal.classList.remove('hidden');
    }

    function setupNextTurn() {
        if (!isHost) return;
        state.turnScore = 0;

        // Check for winner
        const winner = state.teams.find(team => team.score >= state.winningScore);
        if (winner) {
            broadcastToPlayers({ type: 'game_over', payload: { winningTeam: winner } });
            showWinningScreen(winner);
            return;
        }
        
        state.currentTeamIndex = (state.currentTeamIndex + 1) % state.teams.length;
        
        // Tell next player it's their turn
        const allConns = [null, ...playerConnections.values()];
        const nextConn = allConns[state.currentTeamIndex];
        if(nextConn) {
            nextConn.send({ type: 'your_turn' });
        } else { // It's the host's turn
            state.isMyTurn = true;
        }

        broadcastToPlayers({ type: 'state_update', payload: { state, availableWords } });
        renderGameUI();
    }
    
    function showWinningScreen(winningTeam) {
        state.gameActive = false;
        turnOverModal.classList.add('hidden');
        winningTeamName.textContent = winningTeam.name;
        winningScreen.classList.remove('hidden');
        setTimeout(() => {
            winningModalContent.classList.remove('scale-95', 'opacity-0');
        }, 50);
    }
    
    function resetGame() {
        if(!isHost) return;
        broadcastToPlayers({ type: 'reset' });
        window.location.reload();
    }
});
</script>

</body>
</html>
