document.addEventListener('DOMContentLoaded', () => {
    // =========================================================================
    // MULTIPLAYER LOGIC (PeerJS)
    // =========================================================================
    let peer;
    let hostConn; // For clients: connection to the host
    const connections = new Map(); // For host: map of peerId -> connection
    let myPeerId = null;
    let myName = `שחקן ${Math.floor(Math.random() * 1000)}`;
    let isHost = false;
    let isMyTurn = false;

    // New UI Elements
    const startSinglePlayerBtn = document.getElementById('start-single-player-btn');
    const hostGameBtn = document.getElementById('host-game-btn');
    const joinGameBtn = document.getElementById('join-game-btn');
    const joinGameInput = document.getElementById('join-game-input');
    const lobbyScreen = document.getElementById('lobby-screen');
    const gameCodeDisplay = document.getElementById('game-code-display');
    const qrCodeContainer = document.getElementById('qr-code');
    const playerList = document.getElementById('player-list');
    const startMultiplayerGameBtn = document.getElementById('start-multiplayer-game-btn');
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    const cardPrompt = document.getElementById('card-prompt');

    // Multiplayer Event Listeners
    hostGameBtn.addEventListener('click', hostGame);
    joinGameBtn.addEventListener('click', joinGame);
    backToMenuBtn.addEventListener('click', () => location.reload());
    startMultiplayerGameBtn.addEventListener('click', () => {
        if (isHost) startMultiplayerGame();
    });

    function initializePeer(id = null) {
        if(peer) peer.destroy(); // Ensure old connection is closed
        peer = id ? new Peer(id) : new Peer();
        
        peer.on('open', (id) => {
            myPeerId = id;
            console.log('My peer ID is: ' + id);

            if (isHost) {
                setupLobby(id);
            }
        });

        peer.on('connection', (conn) => {
            console.log('Player trying to connect:', conn.peer);
            conn.on('open', () => {
                connections.set(conn.peer, conn);
                conn.on('data', (data) => handleClientMessage(conn.peer, data));
                conn.on('close', () => {
                    console.log(`Player ${conn.peer} disconnected.`);
                    connections.delete(conn.peer);
                    updatePlayerList();
                    broadcast({ type: 'playerListUpdate', players: getPlayerListData() });
                });
            });
        });

        peer.on('error', (err) => {
            console.error('PeerJS error:', err);
            if(err.type === 'peer-unavailable') {
                alert('לא ניתן להתחבר למשחק. ודא שהקוד נכון והמארח עדיין בלובי.');
            } else {
                 alert(`אירעה שגיאת חיבור: ${err.message}`);
            }
        });
    }

    function hostGame() {
        isHost = true;
        initializePeer();
        setupScreen.classList.add('hidden');
        lobbyScreen.classList.remove('hidden');
        updatePlayerList();
    }

    function setupLobby(gameId) {
        gameCodeDisplay.textContent = gameId;
        const gameUrl = `${window.location.href.split('?')[0]}?join=${gameId}`;
        qrCodeContainer.innerHTML = '';
        const qr = qrcode(0, 'L');
        qr.addData(gameUrl);
        qr.make();
        qrCodeContainer.innerHTML = qr.createImgTag(5, 4);
    }

    function joinGame() {
        const hostId = joinGameInput.value.trim();
        if (!hostId) {
            alert('יש להכניס קוד משחק.');
            return;
        }
        isHost = false;
        initializePeer();

        setTimeout(() => {
            console.log(`Attempting to connect to host: ${hostId}`);
            hostConn = peer.connect(hostId, { reliable: true });

            hostConn.on('open', () => {
                console.log('Successfully connected to host.');
                hostConn.send({ type: 'join', name: myName });
                setupScreen.classList.add('hidden');
                lobbyScreen.classList.remove('hidden'); // Show a "waiting" view
                document.getElementById('setup-options').classList.add('hidden');
                lobbyScreen.querySelector('h2').textContent = "ממתין למארח...";
                qrCodeContainer.classList.add('hidden');
                gameCodeDisplay.classList.add('hidden');
                startMultiplayerGameBtn.classList.add('hidden');
            });

            hostConn.on('data', handleHostMessage);

            hostConn.on('close', () => {
                alert('החיבור למארח נותק.');
                location.reload();
            });
        }, 500);
    }

    // Check for join link in URL on page load
    window.addEventListener('load', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const joinId = urlParams.get('join');
        if (joinId) {
            joinGameInput.value = joinId;
            joinGame();
        }
    });

    function updatePlayerList() {
        if (!isHost) return;
        playerList.innerHTML = '';
        const players = getPlayerListData();
        players.forEach(p => {
            const li = document.createElement('div');
            li.textContent = p.name;
            li.className = "bg-gray-100 p-2 rounded";
            playerList.appendChild(li);
        });
    }

    function getPlayerListData() {
        return [
            { peerId: myPeerId, name: `${myName} (מארח)` },
            ...Array.from(connections.values()).map(c => ({ peerId: c.peer, name: c.metadata.name }))
        ];
    }

    function broadcast(data) {
        if (!isHost) return;
        console.log('Broadcasting to all clients:', data);
        connections.forEach(conn => conn.send(data));
    }

    function sendTo(peerId, data) {
        if (!isHost) return;
        const conn = connections.get(peerId);
        if (conn) {
            console.log(`Sending to ${peerId}:`, data);
            conn.send(data);
        }
    }

    // Host: handles messages FROM clients
    function handleClientMessage(peerId, data) {
        if (!isHost) return;

        if (data.type === 'join') {
            const conn = connections.get(peerId);
            conn.metadata = { name: data.name };
            console.log(`Player ${data.name} (${peerId}) joined.`);
            updatePlayerList();
            broadcast({ type: 'playerListUpdate', players: getPlayerListData() });
        } else if (data.type === 'action') {
            const currentTeam = state.teams[state.currentTeamIndex];
            // Ensure the action is coming from the current player
            if (peerId !== currentTeam.currentPlayerPeerId) {
                console.warn(`Action from wrong player. Expected ${currentTeam.currentPlayerPeerId}, got ${peerId}`);
                return;
            }
            
            if (data.action === 'correct') {
                handleCorrect();
            } else if (data.action === 'skip') {
                handleSkip();
            }
        }
    }

    // Client: handles messages FROM host
    function handleHostMessage(data) {
        if (isHost) return;

        if (data.type === 'playerListUpdate') {
            playerList.innerHTML = '';
            data.players.forEach(p => {
                 const li = document.createElement('div');
                 li.textContent = p.name;
                 li.className = "bg-gray-100 p-2 rounded";
                 playerList.appendChild(li);
            });
        } else if (data.type === 'gameStart') {
            Object.assign(state, data.state);
            availableWords = data.words;
            lobbyScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            renderScoreboard();
            updateTurnIndicator();
            editScoresBtn.classList.add('hidden'); // Clients can't edit scores
        } else if (data.type === 'stateUpdate') {
            Object.assign(state, data.newState);
            updateScoreDisplay();
            updateTurnIndicator();
            
            // Check for end of turn modal
            if (data.showTurnOver) {
                finishedTeamName.textContent = data.finishedTeam;
                turnScoreDisplay.textContent = data.turnScore;
                turnOverModal.classList.remove('hidden');
            } else {
                turnOverModal.classList.add('hidden');
            }

            // Check for winner
            if (data.winner) {
                endGame(data.winner);
            }

        } else if (data.type === 'newTurn') {
            isMyTurn = false;
            wordCard.classList.remove('is-flipped');
            actionButtons.classList.add('hidden');
            timerDisplay.parentElement.classList.remove('animate-pulse', 'bg-red-200');
            timerDisplay.textContent = state.roundTime;
            turnOverModal.classList.add('hidden');
        } else if (data.type === 'yourTurn') {
            isMyTurn = true;
            cardPrompt.textContent = "זה התור שלך! הפך את הקלף.";
            countdownModal.classList.add('hidden');
        } else if (data.type === 'countdown') {
            countdownModal.classList.remove('hidden');
            countdownDisplay.textContent = data.count;
        } else if (data.type === 'startTimer') {
            countdownModal.classList.add('hidden');
            if (isMyTurn) {
                wordCard.classList.add('is-flipped');
                actionButtons.classList.remove('hidden');
                wordDisplay.textContent = data.word;
            }
            startTimer(false); // Start timer visually, without host logic
        } else if (data.type === 'timerUpdate') {
            timerDisplay.textContent = data.timeLeft;
             if (data.timeLeft <= 10 && !timerDisplay.parentElement.classList.contains('animate-pulse')) {
                timerDisplay.parentElement.classList.add('animate-pulse', 'bg-red-200');
            }
        } else if (data.type === 'showWord') {
             wordDisplay.textContent = data.word;
        }
    }

    // =========================================================================
    // ORIGINAL GAME LOGIC (Modified for Multiplayer)
    // =========================================================================
    const defaultWords = ["שולחן", "כסא", "מחשב", "טלפון", "אהבה", "לרוץ", "שמח", "מכונית", "כלב", "חתול", "שמש", "ירח", "ספר", "בית ספר", "ים", "חופש", "אוכל", "ארנק", "משקפיים", "עגבניה", "מלפפון", "ענן", "גשם", "מטריה", "כדורגל", "כדורסל", "מטוס", "רכבת", "אופניים", "מוזיקה", "גיטרה", "פסנתר", "יום הולדת", "מתנה", "בלון", "עוגה", "חתונה", "תינוק", "משפחה", "חברים", "עבודה", "כסף", "בנק", "קניון", "חנות", "בגד ים", "מגבת", "כובע", "נעליים", "גרביים", "חולצה", "מכנסיים", "שמלה", "טלוויזיה", "סרט", "חדשות", "אינטרנט", "מקלדת", "עכבר", "מדפסת", "וילון", "חלון", "דלת", "מפתח", "מיטה", "שמיכה", "כרית", "ארון", "מנורה", "מראה", "מברשת שיניים", "סבון", "שמפו", "מלחמה", "שלום", "צבא", "חייל", "מדינה", "דגל", "תקווה", "חלום", "כעס", "פחד", "בדיחה", "צחוק", "דמעה", "חיוך", "לב", "מוח", "יד", "רגל", "אף", "אוזן", "פה", "עין", "שיער", "ציפורן", "אצבע", "קיץ", "חורף", "אביב", "סתיו", "פרח", "עץ", "דשא", "נהר", "הר", "מדבר", "ג'ונגל", "מפה", "מצפן", "כוכב", "גלקסיה", "כדור הארץ", "חללית", "אסטרונאוט", "מדען", "רופא", "מורה", "שוטר", "כבאי", "טבח", "זמר", "שחקן", "רקדן", "צייר", "סופר", "אריה", "נמר", "פיל", "ג'ירפה", "קוף", "זברה", "היפופוטם", "תנין", "נחש", "צב", "דולפין", "כריש", "לוויתן", "פינגווין", "דוב", "זאב", "שועל", "צבי", "ינשוף", "נשר", "מהנדס", "עורך דין", "מעצב", "מתכנת", "אמן", "גנן", "ספר", "אופה", "קונדיטור", "פסטה", "פיצה", "המבורגר", "סושי", "שניצל", "אורז", "תפוח אדמה", "בטטה", "גזר", "בצל", "שום", "פלפל", "חציל", "קישוא", "ברוקולי", "כרובית", "תירס", "אפונה", "חומוס", "טחינה", "פלאפל", "שווארמה", "קפה", "תה", "מיץ", "יין", "בירה", "ירושלים", "תל אביב", "חיפה", "באר שבע", "אילת", "מצרים", "ירדן", "ארצות הברית", "סין", "יפן", "רוסיה", "צרפת", "אנגליה", "איטליה", "ספרד", "גרמניה", "בית קפה", "מסעדה", "ספריה", "מוזיאון", "תיאטרון", "קולנוע", "בריכה", "פארק", "גן חיות", "שדה תעופה", "תחנת רכבת", "גולגולת", "עמוד שדרה", "צלעות", "כתף", "מרפק", "שורש כף היד", "ברך", "קרסול", "עקב", "ריאות", "כבד", "קיבה", "אגם", "נחל", "מפל", "גבעה", "צוק", "חוף", "אי", "יער", "שדה", "כרם", "מערה", "הר געש", "כוכב", "צעיף", "כפפות", "עניבה", "חגורה", "צמיד", "שרשרת", "עגילים", "טבעת", "שעון", "תיק", "תרמיל", "מזוודה", "מטפחת", "פטיש", "מברג", "מסור", "צבת", "מקדחה", "מטר", "שפכטל", "אומץ", "סבלנות", "קנאה", "גאווה", "בלבול", "הפתעה", "אכזבה", "סקרנות", "ביטחון", "עצלנות", "נדיב", "קמצן", "לכתוב", "לקרוא", "לצייר", "לשיר", "לרקוד", "לבשל", "לאפות", "לנקות", "לסדר", "לקנות", "למכור", "לטייל", "לנהוג", "לטוס", "לשחות", "לצלול", "לטפס", "לגלוש", "להחליק", "לחשוב", "לזכור", "לשכוח", "להבין", "להסביר", "לשאול", "לענות", "להקשיב", "לדבר", "לצעוק", "ללחוש", "ספה", "כורסה", "שטיח", "תמונה", "עציץ", "אגרטל", "סיר", "מחבת", "צלחת", "קערה", "כוס", "ספל", "קומקום", "מיקרוגל", "תנור", "מקרר", "מקפיא", "מדיח כלים", "מכונת כביסה", "מייבש", "מגהץ", "קרש גיהוץ", "שואב אבק", "מטאטא", "יעה", "דלי", "סמרטוט", "טניס", "שחייה", "ריצה", "אופניים", "יוגה", "פילאטיס", "הרמת משקולות", "גלישה", "סקי", "שייט", "דייג", "צילום", "נגינה", "משחק מחשב", "טיולים", "קמפינג", "דמוקרטיה", "קפיטליזם", "סוציאליזם", "היסטוריה", "גאוגרפיה", "מתמטיקה", "פיזיקה", "כימיה", "ביולוגיה", "פילוסופיה", "פסיכולוגיה", "אומנות", "מדע", "טכנולוגיה", "חוק", "צדק", "חופש", "שוויון", "אחריות", "הצלחה", "כישלון", "עתיד", "עבר", "הווה", "אוטובוס", "מונית", "משאית", "קטנוע", "מסוק", "ספינה", "יאכטה", "ראש ממשלה", "קורקינט", "גורד שחקים", "מגדל", "ארמון", "טירה", "אוהל", "בית חולים", "מרפאה", "משטרה", "עירייה", "כנסת", "בית משפט", "פסטיבל", "קונצרט", "הצגה", "תערוכה", "הפגנה", "בחירות", "מסיבה", "אזכרה", "טקס", "אולימפיאדה", "עץ", "מתכת", "פלסטיק", "זכוכית", "בד", "צמר", "עור", "אבן", "חול", "מים", "אוויר", "אש", "אדום", "כחול", "צהוב", "ירוק", "כתום", "סגול", "ורוד", "חום", "שחור", "לבן", "אפור", "כסף", "זהב", "אבא", "אמא", "אח", "אחות", "סבא", "סבתא", "דוד", "דודה", "בן דוד", "בת דודה", "אחיין", "אחיינית", "דרכון", "תעודת זהות", "רישיון נהיגה", "כרטיס אשראי", "מזומן", "חשבון", "קבלה", "אחריות", "חוזה", "סוד","שקר", "אמת", "רעיון", "בעיה", "פתרון", "שאלה", "תשובה", "סיפור", "שיר", "סמל", "סימן", "ארוחת בוקר", "ארוחת צהריים", "ארוחת ערב", "קינוח", "מנה ראשונה", "מנה עיקרית", "אלרגיה", "ויטמין", "חלבון", "פחמימה", "שומן", "דיאטה", "מתכון", "תבלין", "רוטב", "מלח", "סוכר", "קמח", "שמן", "חמאה", "גבינה", "ביצה", "חלב", "יוגורט", "לחם", "עוגיה", "שוקולד", "גלידה", "סוכריה", "מסטיק", "אנרגיה", "כוח", "מהירות", "גובה", "רוחב", "עומק", "משקל", "טמפרטורה", "לחץ", "רעש", "שקט", "אור", "חושך", "צורה", "גודל", "כמות", "איכות", "מחיר", "הנחה", "מבצע", "חשבונית", "עודף", "טיפ", "מס", "תקציב", "הוצאה", "הכנסה", "חיסכון", "השקעה", "בורסה", "מניה", "ריבית", "הלוואה", "משכנתא", "ביטוח", "פנסיה", "פרישה", "הורים", "ילדים", "סבים", "נכדים", "בעל", "אישה", "בן זוג", "בת זוג", "חתן", "כלה", "גיס", "גיסה", "חם", "חמות", "ילד", "נער", "מבוגר", "קשיש", "ידיד", "אדם", "איש", "אישה", "ראש", "פנים", "שן", "לשון", "שפתיים", "סנטר", "צוואר", "גב", "חזה", "בטן", "זרוע", "כף רגל", "עור", "כליה", "עצם", "שריר", "דם", "סוס", "פרה", "חמור", "כבשה", "עז", "תרנגול", "ברווז", "יונה", "ציפור", "פרפר", "דבורה", "נמלה", "עכביש", "יתוש", "זבוב", "סרטן", "תמנון", "גמל", "קינואה", "קוסקוס", "בורגול", "חסה", "פטריה", "דלעת", "תפוח", "בננה", "תפוז", "ענבים", "אבטיח", "מלון", "תות", "מנגו", "אפרסק", "משמש", "שזיף", "לימון", "אבוקדו", "עדשים", "שעועית", "פול", "שמנת", "בשר", "עוף", "קציצה", "סטייק", "נקניקיה", "קרואסון", "בורקס", "סלט", "מרק", "כריך", "חביתה", "טוסט", "סודה", "שוקו", "חרדל", "קטשופ", "מיונז", "שידה", "מדף", "מזגן", "סכו\"ם", "מזלג", "סכין", "כף", "כפית", "קרש חיתוך", "פותחן", "חדר שינה", "סלון", "מטבח", "חדר אמבטיה", "שירותים", "מרפסת", "גינה", "עיתון", "משחת שיניים", "נייר טואלט", "חצאית", "ג'ינס", "סוודר", "ז'קט", "מעיל", "משקפי שמש", "תכשיטים", "שלג", "ברד", "רוח", "סופה", "ברק", "רעם", "קשת בענן", "עמק", "שיח", "דירה", "בניין", "רחוב", "עיר", "יבשת", "אוניברסיטה", "גן ילדים", "בית מרקחת", "חדר כושר", "דואר", "מפעל", "משרד", "אופנוע", "מלצר", "פוליטיקאי", "נשיא", "לקפוץ", "לשבת", "לעמוד", "לשכב", "לומר", "לדעת", "להתקלח", "להתלבש", "לרצות", "להזדקק", "להרגיש", "לבנות", "לתקן", "לצלם", "גדול", "קטן", "ארוך", "קצר", "עגול", "מרובע", "עצוב", "עייף", "רעב", "צמא", "מפחד", "מופתע", "נרגש", "משועמם", "טוב", "רע", "יפה", "מכוער", "פשוט", "מורכב", "חיים", "מוות", "זמן", "סיבה", "תוצאה", "תעודה", "מחק", "על", "עם", "בלי", "ליד", "מתחת", "כל", "הרבה", "קצת", "מאוד", "תמיד", "לפעמים", "אף פעם", "מה נשמע", "מה שלומך", "תודה רבה", "על לא דבר", "אין בעיה", "לא נורא", "שנה טובה", "חג שמח"];
    let words = [...defaultWords]; let customWords = []; let availableWords = []; const state = { teams: [], currentTeamIndex: 0, timerInterval: null, timeLeft: 60, gameActive: false, turnScore: 0, roundTime: 60, winningScore: 20, inLastRound: false, inTieBreaker: false }; const successSound = new Audio('https://cdn.jsdelivr.net/gh/hutzpa/aliassounds/success.mp3'); const loseSound = new Audio('https://cdn.jsdelivr.net/gh/hutzpa/aliassounds/lose.mp3'); const victorySound = new Audio('https://cdn.jsdelivr.net/gh/hutzpa/aliassounds/victory.mp3'); const tickingSound = new Audio('https://cdn.jsdelivr.net/gh/hutzpa/aliassounds/ticking.mp3'); const setupScreen = document.getElementById('setup-screen'); const gameScreen = document.getElementById('game-screen'); const turnOverModal = document.getElementById('turn-over-modal'); const winningScreen = document.getElementById('winning-screen'); const winningModalContent = document.getElementById('winning-modal-content'); const howToPlayModal = document.getElementById('how-to-play-modal'); const customWordsModal = document.getElementById('custom-words-modal'); const teamInputsContainer = document.getElementById('team-inputs-container'); const addTeamBtn = document.getElementById('add-team-btn'); const scoreOptions = document.getElementById('score-options'); const howToPlayBtn = document.getElementById('how-to-play-btn'); const closeHowToPlayBtn = document.getElementById('close-how-to-play-btn'); const addWordsBtn = document.getElementById('add-words-btn'); const closeCustomWordsBtn = document.getElementById('close-custom-words-btn'); const saveCustomWordsBtn = document.getElementById('save-custom-words-btn'); const customWordsTextarea = document.getElementById('custom-words-textarea'); const scoresContainer = document.getElementById('scores-container'); const timerDisplay = document.getElementById('timer'); const wordDisplay = document.getElementById('word-display'); const wordCard = document.getElementById('word-card'); const actionButtons = document.getElementById('action-buttons'); const currentTeamNameCard = document.getElementById('current-team-name-card'); const correctBtn = document.getElementById('correct-btn'); const skipBtn = document.getElementById('skip-btn'); const finishedTeamName = document.getElementById('finished-team-name'); const turnScoreDisplay = document.getElementById('turn-score'); const nextTurnBtn = document.getElementById('next-turn-btn'); const winningTeamName = document.getElementById('winning-team-name'); const playAgainBtn = document.getElementById('play-again-btn'); const countdownModal = document.getElementById('countdown-modal'); const countdownDisplay = document.getElementById('countdown-display'); const editScoresBtn = document.getElementById('edit-scores-btn'); const editScoresModal = document.getElementById('edit-scores-modal'); const closeEditScoresBtn = document.getElementById('close-edit-scores-btn'); const saveScoresBtn = document.getElementById('save-scores-btn'); const editScoresList = document.getElementById('edit-scores-list'); startSinglePlayerBtn.addEventListener('click', startGame); wordCard.addEventListener('click', flipCardAndStartTurn); correctBtn.addEventListener('click', () => handleAction('correct')); skipBtn.addEventListener('click', () => handleAction('skip')); nextTurnBtn.addEventListener('click', setupNextTurn); playAgainBtn.addEventListener('click', resetGame); howToPlayBtn.addEventListener('click', () => howToPlayModal.classList.remove('hidden')); closeHowToPlayBtn.addEventListener('click', () => howToPlayModal.classList.add('hidden')); addWordsBtn.addEventListener('click', () => customWordsModal.classList.remove('hidden')); closeCustomWordsBtn.addEventListener('click', () => customWordsModal.classList.add('hidden')); saveCustomWordsBtn.addEventListener('click', saveCustomWords); addTeamBtn.addEventListener('click', addTeamInput); teamInputsContainer.addEventListener('click', (e) => { if (e.target && e.target.classList.contains('remove-team-btn')) { e.target.parentElement.remove(); } }); scoreOptions.addEventListener('click', (e) => { if (e.target.classList.contains('score-option')) { scoreOptions.querySelectorAll('.score-option').forEach(btn => btn.classList.remove('selected')); e.target.classList.add('selected'); } }); editScoresBtn.addEventListener('click', openEditScoresModal); closeEditScoresBtn.addEventListener('click', () => editScoresModal.classList.add('hidden')); saveScoresBtn.addEventListener('click', saveScores); editScoresList.addEventListener('click', handleScoreChangeInModal); function playSound(sound) { sound.currentTime = 0; sound.play().catch(e => console.log("Audio play failed:", e)); } function addTeamInput() { const teamCount = teamInputsContainer.children.length; const newTeamInput = document.createElement('div'); newTeamInput.className = 'flex items-center gap-2'; newTeamInput.innerHTML = ` <label for="team${teamCount + 1}-name" class="sr-only">שם קבוצה ${teamCount + 1}</label> <input type="text" id="team${teamCount + 1}-name" placeholder="שם קבוצה ${teamCount + 1}" class="team-name-input w-full p-3 border-2 border-gray-300 rounded-lg text-center text-lg focus:ring-2 focus:ring-red-500 focus:border-red-500 transition"> <button class="remove-team-btn text-gray-400 hover:text-red-500 text-2xl font-bold">&times;</button> `; teamInputsContainer.appendChild(newTeamInput); } function saveCustomWords() { const newWords = customWordsTextarea.value.split('\n').map(word => word.trim()).filter(word => word.length > 0); if (newWords.length > 0) { const newUniqueWords = newWords.filter(w => !customWords.includes(w)); customWords.push(...newUniqueWords); words = [...new Set([...defaultWords, ...customWords])]; const originalText = saveCustomWordsBtn.textContent; saveCustomWordsBtn.textContent = 'נשמר!'; saveCustomWordsBtn.disabled = true; saveCustomWordsBtn.classList.remove('btn-red'); saveCustomWordsBtn.classList.add('bg-green-500'); setTimeout(() => { customWordsModal.classList.add('hidden'); saveCustomWordsBtn.textContent = originalText; saveCustomWordsBtn.classList.add('btn-red'); saveCustomWordsBtn.classList.remove('bg-green-500'); saveCustomWordsBtn.disabled = false; customWordsTextarea.value = ''; }, 1500); } else { customWordsModal.classList.add('hidden'); } } function shuffle(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } } function getNextWord() { if (availableWords.length === 0) { console.log("Word deck empty. Reshuffling..."); availableWords = [...words]; shuffle(availableWords); } return availableWords.pop(); }
    function startMultiplayerGame() {
        if (!isHost) return;
        const players = getPlayerListData();
        const teamInputs = document.querySelectorAll('.team-name-input');
        
        if (players.length < 2 || players.length < teamInputs.length) {
            alert('צריך לפחות שני שחקנים, ושחקן אחד לכל קבוצה.');
            return;
        }

        // Assign players to teams
        state.teams = [];
        teamInputs.forEach((input, index) => {
            state.teams.push({ 
                name: input.value || `קבוצה ${index + 1}`, 
                score: 0,
                id: index,
                playerIds: [], // array of peerIds for this team
                currentPlayerIndex: -1 // index in playerIds array
            });
        });

        players.forEach((player, index) => {
            const teamIndex = index % state.teams.length;
            state.teams[teamIndex].playerIds.push(player.peerId);
        });
        
        // Set first player
        state.teams.forEach(team => {
            if(team.playerIds.length > 0) {
                team.currentPlayerIndex = 0;
            }
        });
        const firstTeam = state.teams[0];
        firstTeam.currentPlayerPeerId = firstTeam.playerIds[0];

        state.winningScore = parseInt(scoreOptions.querySelector('.selected').dataset.value) || 20;
        state.currentTeamIndex = 0;
        availableWords = [...words];
        shuffle(availableWords);

        broadcast({ type: 'gameStart', state: state, words: availableWords });

        lobbyScreen.classList.add('hidden');
        gameScreen.classList.remove('hidden');
        renderScoreboard();
        updateTurnIndicator();
        prepareNextTurn();
    }

    function startGame() {
        isHost = true; // In single player, the user is the host
        const selectedScore = scoreOptions.querySelector('.selected').dataset.value; state.roundTime = 60; state.winningScore = parseInt(selectedScore) || 20; state.teams = []; state.inLastRound = false; state.inTieBreaker = false; document.getElementById('tie-breaker-banner').classList.add('hidden'); document.getElementById('last-round-banner').classList.add('hidden'); const teamNameInputs = document.querySelectorAll('.team-name-input'); teamNameInputs.forEach((input, index) => { state.teams.push({ name: input.value || `קבוצה ${index + 1}`, score: 0 }); }); state.teams.forEach((team, index) => { team.id = index; }); renderScoreboard(); timerDisplay.textContent = state.roundTime; setupScreen.classList.add('hidden'); gameScreen.classList.remove('hidden'); editScoresBtn.classList.remove('hidden'); availableWords = [...words]; shuffle(availableWords); updateTurnIndicator(); } function renderScoreboard() { scoresContainer.innerHTML = ''; state.teams.forEach(team => { const scoreBox = document.createElement('div'); scoreBox.id = `score-box-${team.id}`; scoreBox.className = 'score-box p-3 rounded-lg text-center shadow-md'; scoreBox.innerHTML = ` <div id="team-name-${team.id}" class="font-bold text-base md:text-lg truncate">${team.name}</div> <div id="team-score-${team.id}" class="text-2xl font-black">${team.score}</div> `; scoresContainer.appendChild(scoreBox); }); } function updateTurnIndicator() { document.querySelectorAll('.score-box').forEach(box => box.classList.remove('active')); const currentTeam = state.teams[state.currentTeamIndex]; if (!currentTeam) return; currentTeamNameCard.textContent = currentTeam.name; const currentScoreBox = document.getElementById(`score-box-${currentTeam.id}`); if (currentScoreBox) { currentScoreBox.classList.add('active'); } 
        cardPrompt.textContent = "הפכו את הקלף כדי להתחיל";
        isMyTurn = true; // In single player, it's always my turn
    }

    function startRoundCountdown() {
        if (!isHost) return;
        editScoresBtn.classList.add('hidden');
        let countdown = 3;
        const doCountdown = () => {
            broadcast({ type: 'countdown', count: countdown });
            countdownModal.classList.remove('hidden');
            countdownDisplay.textContent = countdown;
            if (countdown > 0) {
                countdown--;
                setTimeout(doCountdown, 1000);
            } else {
                const firstWord = getNextWord();
                broadcast({ type: 'startTimer', word: firstWord });
                startTimer(true); // Host starts timer with logic
            }
        };
        doCountdown();
    }

    function flipCardAndStartTurn() { 
        if (state.gameActive || !isMyTurn) return;
        if (isHost) {
            startRoundCountdown();
        }
    } 

    function startTimer(isGameHost) {
        if (isGameHost) {
            state.gameActive = true;
            state.timeLeft = state.roundTime;
            state.timerInterval = setInterval(() => {
                state.timeLeft--;
                broadcast({ type: 'timerUpdate', timeLeft: state.timeLeft });
                if (state.timeLeft === 10) { playSound(tickingSound); }
                if (state.timeLeft <= 0) {
                    endTurn();
                }
            }, 1000);
        } else { // Client-side visual timer
            let localTimeLeft = state.roundTime;
            state.timerInterval = setInterval(() => {
                localTimeLeft--;
                 if (localTimeLeft === 10 && isMyTurn) { playSound(tickingSound); }
                if (localTimeLeft <= 0) {
                    clearInterval(state.timerInterval);
                }
            }, 1000);
        }
    }

    function handleAction(action) {
        if (!isMyTurn) return;
        
        if (isHost && !connections.size) { // Single Player
            if (action === 'correct') handleCorrect();
            else handleSkip();
        } else { // Multiplayer
            hostConn.send({ type: 'action', action: action });
        }
    }

    function handleCorrect() { if (!state.gameActive) return; if (isHost) { playSound(successSound); const currentTeam = state.teams[state.currentTeamIndex]; currentTeam.score++; state.turnScore++; showScoreAnimation(currentTeam.id, 1); updateScoreDisplay(); broadcast({ type: 'stateUpdate', newState: state }); const nextWord = getNextWord(); broadcast({ type: 'showWord', word: nextWord }); } }
    function handleSkip() { if (!state.gameActive) return; if (isHost) { playSound(loseSound); const currentTeam = state.teams[state.currentTeamIndex]; if (currentTeam.score > 0) { currentTeam.score--; showScoreAnimation(currentTeam.id, -1); } updateScoreDisplay(); broadcast({ type: 'stateUpdate', newState: state }); const nextWord = getNextWord(); broadcast({ type: 'showWord', word: nextWord }); } }
    function showScoreAnimation(teamId, amount) { const scoreBox = document.getElementById(`score-box-${teamId}`); if (!scoreBox) return; const animationEl = document.createElement('div'); animationEl.classList.add('score-change'); if (amount > 0) { animationEl.textContent = `+${amount}`; animationEl.classList.add('plus-one'); } else { animationEl.textContent = `${amount}`; animationEl.classList.add('minus-one'); } scoreBox.appendChild(animationEl); setTimeout(() => { animationEl.remove(); }, 800); } 
    function updateScoreDisplay() { state.teams.forEach(team => { const teamScoreEl = document.getElementById(`team-score-${team.id}`); if (teamScoreEl) teamScoreEl.textContent = team.score; }); }

    function endTurn() {
        if(!isHost) return;
        clearInterval(state.timerInterval);
        state.gameActive = false;
        const currentTeam = state.teams[state.currentTeamIndex];
        broadcast({ type: 'stateUpdate', newState: state, showTurnOver: true, finishedTeam: currentTeam.name, turnScore: state.turnScore });
        if(isHost && !connections.size) {
            finishedTeamName.textContent = currentTeam.name;
            turnScoreDisplay.textContent = state.turnScore;
            turnOverModal.classList.remove('hidden');
        }
    }

    function prepareNextTurn() {
        if (!isHost) return;

        // Tell everyone a new turn is starting (resets card, hides buttons)
        broadcast({ type: 'newTurn' });

        // Determine whose turn it is
        const currentTeam = state.teams[state.currentTeamIndex];
        const currentPlayerPeerId = currentTeam.playerIds[currentTeam.currentPlayerIndex];
        
        // Tell that specific player it's their turn
        if(currentPlayerPeerId === myPeerId) { // If host is the current player
            isMyTurn = true;
            cardPrompt.textContent = "זה התור שלך! הפך את הקלף.";
        } else {
            isMyTurn = false;
            sendTo(currentPlayerPeerId, { type: 'yourTurn' });
        }
        cardPrompt.textContent = "ממתין לשחקן...";
    }

    function setupNextTurn() {
        if (!isHost) {
            turnOverModal.classList.add('hidden');
            return;
        }
        
        turnOverModal.classList.add('hidden');
        state.turnScore = 0;
        
        const isLastTeamOfRound = state.currentTeamIndex === state.teams.length - 1;
        if (isLastTeamOfRound) {
            const maxScore = Math.max(...state.teams.map(t => t.score));
            const winners = state.teams.filter(t => t.score === maxScore && t.score >= state.winningScore);
            if (winners.length === 1) {
                broadcast({ type: 'stateUpdate', newState: state, winner: winners[0] });
                endGame(winners[0]);
                return;
            }
        }

        // Advance to next team
        state.currentTeamIndex = (state.currentTeamIndex + 1) % state.teams.length;
        
        // Advance player within that team
        const nextTeam = state.teams[state.currentTeamIndex];
        nextTeam.currentPlayerIndex = (nextTeam.currentPlayerIndex + 1) % nextTeam.playerIds.length;
        nextTeam.currentPlayerPeerId = nextTeam.playerIds[nextTeam.currentPlayerIndex];

        broadcast({ type: 'stateUpdate', newState: state });
        prepareNextTurn();
    }

    function endGame(winningTeam) { 
        clearInterval(state.timerInterval); 
        tickingSound.pause(); 
        playSound(victorySound); 
        state.gameActive = false; 
        winningTeamName.textContent = winningTeam.name; 
        turnOverModal.classList.add('hidden'); 
        editScoresBtn.classList.add('hidden'); 
        winningScreen.classList.remove('hidden'); 
        setTimeout(() => { winningModalContent.classList.remove('scale-95', 'opacity-0'); }, 50); 
    } 
    function resetGame() {
        if(isHost) location.reload();
        else if(hostConn) {
            hostConn.close();
        } else {
            location.reload();
        }
    }
    function openEditScoresModal() { editScoresList.innerHTML = ''; state.teams.forEach(team => { const teamEditRow = document.createElement('div'); teamEditRow.className = 'flex items-center justify-between bg-gray-100 p-3 rounded-lg'; teamEditRow.innerHTML = ` <span class="font-bold text-lg">${team.name}</span> <div class="flex items-center gap-4"> <button data-team-id="${team.id}" data-action="minus" class="w-8 h-8 rounded-full bg-red-200 text-red-700 font-bold text-xl flex items-center justify-center">-</button> <span class="text-2xl font-black w-10 text-center" data-score-for-team="${team.id}">${team.score}</span> <button data-team-id="${team.id}" data-action="plus" class="w-8 h-8 rounded-full bg-green-200 text-green-700 font-bold text-xl flex items-center justify-center">+</button> </div> `; editScoresList.appendChild(teamEditRow); }); editScoresModal.classList.remove('hidden'); } function handleScoreChangeInModal(e) { const action = e.target.dataset.action; const teamId = e.target.dataset.teamId; if (!action || !teamId) return; const scoreSpan = editScoresList.querySelector(`[data-score-for-team="${teamId}"]`); let currentScore = parseInt(scoreSpan.textContent, 10); if (action === 'plus') { currentScore++; } else if (action === 'minus' && currentScore > 0) { currentScore--; } scoreSpan.textContent = currentScore; } function saveScores() { const scoreSpans = editScoresList.querySelectorAll('[data-score-for-team]'); scoreSpans.forEach(span => { const teamId = parseInt(span.dataset.scoreForTeam, 10); const newScore = parseInt(span.textContent, 10); const team = state.teams.find(t => t.id === teamId); if (team) { team.score = newScore; } }); updateScoreDisplay(); editScoresModal.classList.add('hidden'); const anyTeamReachedGoal = state.teams.some(t => t.score >= state.winningScore); if (anyTeamReachedGoal) { state.inLastRound = true; } else { state.inLastRound = false; } }
});
